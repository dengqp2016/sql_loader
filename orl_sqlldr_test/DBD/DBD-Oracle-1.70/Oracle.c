/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of Oracle.xs. Do not edit this file, edit Oracle.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Oracle.xs"
#include "Oracle.h"

#define BIND_PARAM_INOUT_ALLOW_ARRAY

DBISTATE_DECLARE;

#line 17 "Oracle.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 69 "Oracle.c"

XS(XS_DBD__Oracle_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "name=Nullch");
    {
	char *	name;
	I32	RETVAL;
	dXSTARG;

	if (items < 1)
	    name = Nullch;
	else {
	    name = (char *)SvPV_nolen(ST(0));
	}
#line 78 "Oracle.xs"
	if (!ix) {
	if (!name) name = GvNAME(CvGV(cv));
	croak("Unknown DBD::Oracle constant '%s'", name);
	}
	else RETVAL = ix;
#line 98 "Oracle.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle_ORA_OCI); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_ORA_OCI)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 90 "Oracle.xs"
	SV *sv = sv_newmortal();
	sv_setnv(sv, atof(ORA_OCI_VERSION));	/* 9.1! see docs */
	sv_setpv(sv, ORA_OCI_VERSION);		/* 9.10.11.12	*/
	SvNOK_on(sv); /* dualvar hack */
	ST(0) = sv;
#line 122 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle_ora_env_var); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_ora_env_var)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
#line 100 "Oracle.xs"
	char buf[1024];
	char *p = ora_env_var(name, buf, sizeof(buf)-1);
	SV *sv = sv_newmortal();
	if (p)
		sv_setpv(sv, p);
	ST(0) = sv;
#line 147 "Oracle.c"
    }
    XSRETURN(1);
}

#ifdef __CYGWIN32__
#define XSubPPtmpAAAA 1


XS(XS_DBD__Oracle_ora_cygwin_set_env); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_ora_cygwin_set_env)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name, value");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	char *	value = (char *)SvPV_nolen(ST(1));
#line 113 "Oracle.xs"
	ora_cygwin_set_env(name, value);
#line 171 "Oracle.c"
    }
    XSRETURN_EMPTY;
}

#endif /* __CYGWIN32__ */

/* INCLUDE:  Including 'Oracle.xsi' from 'Oracle.xs' */

#include "Driver_xst.h"

XS(XS_DBD__Oracle__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_dbixs_revision)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 36 "./Oracle.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 196 "Oracle.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAB 1


XS(XS_DBD__Oracle__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_discon_all_)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0);
#line 48 "./Oracle.xsi"
    D_imp_drh(drh);
    if (0) ix = ix;     /* avoid unused variable warning */
    ST(0) = dbd_discon_all(drh, imp_drh) ? &sv_yes : &sv_no;
#line 223 "Oracle.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAC 1


XS(XS_DBD__Oracle__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_data_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 62 "./Oracle.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 267 "Oracle.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_DBD__Oracle__db__login); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db__login)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	dbname = ST(1);
	SV *	username = ST(2);
	SV *	password = ST(3);
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 92 "./Oracle.xsi"
    {
    STRLEN lna;
    D_imp_dbh(dbh);
    char *u = (SvOK(username)) ? SvPV(username,lna) : "";
    char *p = (SvOK(password)) ? SvPV(password,lna) : "";
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &sv_yes : &sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &sv_yes : &sv_no;
#endif
    }
#line 311 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_selectall_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 110 "./Oracle.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 333 "Oracle.c"
#line 116 "./Oracle.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::Oracle::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    ST(0) = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
#line 378 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_selectrow_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 166 "./Oracle.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 402 "Oracle.c"
#line 171 "./Oracle.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 458 "Oracle.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAD 1


XS(XS_DBD__Oracle__db_do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_do)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    {
	SV *	dbh = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2);
	}
#line 235 "./Oracle.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 501 "Oracle.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAE 1


XS(XS_DBD__Oracle__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_last_insert_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog, schema, table, field, attr=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	catalog = ST(1);
	SV *	schema = ST(2);
	SV *	table = ST(3);
	SV *	field = ST(4);
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5);
	}
#line 262 "./Oracle.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 539 "Oracle.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_DBD__Oracle__db_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_commit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 274 "./Oracle.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 563 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_rollback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 284 "./Oracle.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 586 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_disconnect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 294 "./Oracle.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? "" : "s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &sv_yes : &sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 620 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_STORE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 317 "./Oracle.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &sv_no;
#line 648 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_FETCH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
#line 331 "./Oracle.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 673 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0);
#line 342 "./Oracle.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* want's ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                    XXX or could just move the DBIc_is(imp_dbh, DBIcf_Executed) test
                    to cover the rollback as well. That just needs sanity checking
                    that DBIcf_Executed is set by any/all possible way to execute a
                    statement that might start a transaction.
                */
                if (DBIc_WARN(imp_dbh)
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
                && (!dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                )
                     warn("Issuing rollback() for database handle being DESTROY'd without explicit disconnect()");
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 738 "Oracle.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAF 1


XS(XS_DBD__Oracle__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_take_imp_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0);
#line 394 "./Oracle.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::Oracle::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 775 "Oracle.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAG 1


XS(XS_DBD__Oracle__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_data_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 418 "./Oracle.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 819 "Oracle.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_DBD__Oracle__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st__prepare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	statement = ST(1);
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2);
	}
#line 447 "./Oracle.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &sv_yes : &sv_no;
#endif
    }
#line 857 "Oracle.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAH 1


XS(XS_DBD__Oracle__st_rows); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_rows)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 464 "./Oracle.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 881 "Oracle.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAI 1


XS(XS_DBD__Oracle__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_bind_col)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	col = ST(1);
	SV *	ref = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 479 "./Oracle.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &sv_yes : &sv_no;
                break;
    default:    ST(0) = &sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 941 "Oracle.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS(XS_DBD__Oracle__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_bind_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 517 "./Oracle.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &sv_yes : &sv_no;
    }
#line 990 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_bind_param_inout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 547 "./Oracle.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &sv_yes : &sv_no;
    }
#line 1044 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_execute); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_execute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0);
#line 578 "./Oracle.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1081 "Oracle.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAJ 1


XS(XS_DBD__Oracle__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_execute_for_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0);
	SV *	fetch_tuple_sub = ST(1);
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2);
	}
#line 606 "./Oracle.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 1115 "Oracle.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_DBD__Oracle__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_fetchrow_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 621 "./Oracle.xsi"
    D_imp_sth(sth);
    AV *av;
    if (0) ix = ix;     /* avoid unused variable warning */
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1141 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_fetchrow_array)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 634 "./Oracle.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        if (0) ix = ix; /* avoid unused variable warning */
    }
#line 1175 "Oracle.c"
	PUTBACK;
	return;
    }
}


XS(XS_DBD__Oracle__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_fetchall_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0);
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1);
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2);
	}
#line 654 "./Oracle.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::Oracle::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        ST(0) = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
    }
#line 1217 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_finish)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 668 "./Oracle.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &sv_yes : &sv_no;
#endif
#line 1253 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_blob_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0);
	int	field = (int)SvIV(ST(1));
	long	offset = (long)SvIV(ST(2));
	long	len = (long)SvIV(ST(3));
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4);
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5));
	}
#line 696 "./Oracle.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1297 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_STORE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 712 "./Oracle.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &sv_no;
#line 1325 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_FETCH_attrib)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
#line 729 "./Oracle.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    if (0) ix = ix;     /* avoid unused variable warning */
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1353 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 742 "./Oracle.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1405 "Oracle.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Oracle.xs' from 'Oracle.xsi' */


XS(XS_DBD__Oracle__st_ora_stmt_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_stmt_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 126 "Oracle.xs"
	D_imp_sth(sth);
#line 1429 "Oracle.c"
#line 128 "Oracle.xs"
	{
   	XSRETURN_IV( imp_sth->stmt_type);
}
#line 1434 "Oracle.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DBD__Oracle__st_ora_stmt_type_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_stmt_type_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 136 "Oracle.xs"
	D_imp_sth(sth);
#line 1454 "Oracle.c"
#line 138 "Oracle.xs"
	char *p = oci_stmt_type_name(imp_sth->stmt_type);
	SV *sv = sv_newmortal();
	if (p)
	  sv_setpv(sv, p);
	ST(0) = sv;
#line 1461 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_ora_scroll_position); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_scroll_position)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 148 "Oracle.xs"
	D_imp_sth(sth);
#line 1481 "Oracle.c"
#line 150 "Oracle.xs"
	{
   	XSRETURN_IV( imp_sth->fetch_position);
}
#line 1486 "Oracle.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DBD__Oracle__st_ora_fetch_scroll); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_fetch_scroll)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "sth, fetch_orient, fetch_offset");
    {
	SV *	sth = ST(0);
	IV	fetch_orient = (IV)SvIV(ST(1));
	IV	fetch_offset = (IV)SvIV(ST(2));
#line 160 "Oracle.xs"
	D_imp_sth(sth);
#line 1508 "Oracle.c"
#line 162 "Oracle.xs"
	{
	AV *av;
 	imp_sth->fetch_orient=fetch_orient;
	imp_sth->fetch_offset=fetch_offset;
	av = dbd_st_fetch(sth,imp_sth);
    imp_sth->fetch_offset = 1;                  /* default back to 1 for fetch */
 	imp_sth->fetch_orient=OCI_FETCH_NEXT;       /* default back to fetch next */
	ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
}
#line 1519 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_ora_bind_param_inout_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_bind_param_inout_array)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "sth, param, av_ref, maxlen, attribs");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	av_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs = ST(4);
#line 180 "Oracle.xs"
	{
	IV sql_type = 0;
	D_imp_sth(sth);
	SV *av_value;
	if (!SvROK(av_ref) || SvTYPE(SvRV(av_ref)) != SVt_PVAV)
	 	 croak("bind_param_inout_array needs a reference to a array value");
	av_value = av_ref;
	if (SvREADONLY(av_value))
		croak("Modification of a read-only value attempted");
	if (attribs) {
		if (SvNIOK(attribs)) {
			sql_type = SvIV(attribs);
			attribs = Nullsv;
		}
		else {
	   	 	SV **svp;
			DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
			DBD_ATTRIB_GET_IV(attribs, "ora_type",4, svp, sql_type);
		}
	}
	ST(0) = dbd_bind_ph(sth, imp_sth, param,av_value, sql_type, attribs, TRUE, maxlen)
		? &PL_sv_yes : &PL_sv_no;
}
#line 1565 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_ora_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 209 "Oracle.xs"
	/* fetchrow: but with scalar fetch returning NUM_FIELDS for Oraperl	*/
	/* This code is called _directly_ by Oraperl.pm bypassing the DBI.	*/
	/* as a result we have to do some things ourselves (like calling	*/
	/* CLEAR_ERROR) and we loose the tracing that the DBI offers :-(	*/
	D_imp_sth(sth);
	AV *av;
	int debug = DBIc_DEBUGIV(imp_sth);
	if (DBIS->debug > debug)
	debug = DBIS->debug;
	DBIh_CLEAR_ERROR(imp_sth);
	if (GIMME == G_SCALAR) {	/* XXX Oraperl	*/
	/* This non-standard behaviour added only to increase the	*/
	/* performance of the oraperl emulation layer (Oraperl.pm)	*/
	if (!imp_sth->done_desc && !dbd_describe(sth, imp_sth))
		XSRETURN_UNDEF;
	XSRETURN_IV(DBIc_NUM_FIELDS(imp_sth));
	}
	if (debug >= 2)
		PerlIO_printf(DBILOGFP, "	-> ora_fetch\n");
	av = dbd_st_fetch(sth, imp_sth);
	if (av) {
	int num_fields = AvFILL(av)+1;
	int i;
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
		PUSHs(AvARRAY(av)[i]);
	}
	if (debug >= 2)
		PerlIO_printf(DBILOGFP, "	<- (...) [%d items]\n", num_fields);
	}
	else {
	if (debug >= 2)
		PerlIO_printf(DBILOGFP, "	<- () [0 items]\n");
	}
	if (debug >= 2 && SvTRUE(DBIc_ERR(imp_sth)))
		PerlIO_printf(DBILOGFP, "	!! ERROR: %s %s",
			neatsvpv(DBIc_ERR(imp_sth),0), neatsvpv(DBIc_ERRSTR(imp_sth),0));
#line 1623 "Oracle.c"
	PUTBACK;
	return;
    }
}


XS(XS_DBD__Oracle__st_ora_execute_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_execute_array)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "sth, tuples, exe_count, tuples_status, err_count, cols=&PL_sv_undef");
    {
	SV *	sth = ST(0);
	SV *	tuples = ST(1);
	IV	exe_count = (IV)SvIV(ST(2));
	SV *	tuples_status = ST(3);
	SV *	cols;
	SV *	err_count = ST(4);
#line 256 "Oracle.xs"
	D_imp_sth(sth);
	int retval;
#line 1650 "Oracle.c"

	if (items < 6)
	    cols = &PL_sv_undef;
	else {
	    cols = ST(5);
	}
#line 259 "Oracle.xs"
	/* XXX Need default bindings if any phs are so far unbound(?) */
	/* XXX this code is duplicated in selectrow_arrayref above  */
	if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
		DBIc_ROW_COUNT(imp_sth) = 0;
	retval = ora_st_execute_array(sth, imp_sth, tuples, tuples_status,
								  cols, (ub4)exe_count,err_count);
	/* XXX Handle return value ... like DBI::execute_array(). */
	/* remember that dbd_st_execute must return <= -2 for error */
	if (retval == 0)			/* ok with no rows affected	 */
		XST_mPV(0, "0E0");	  /* (true but zero)			  */
	else if (retval < -1)	   /* -1 == unknown number of rows */
		XST_mUNDEF(0);		  /* <= -2 means error			*/
	else
		XST_mIV(0, retval);	 /* typically 1, rowcount or -1  */
#line 1672 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__st_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_cancel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 279 "Oracle.xs"
	D_imp_sth(sth);
	ST(0) = dbd_st_cancel(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#line 1693 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_db_startup); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_db_startup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, attribs");
    {
	SV *	dbh = ST(0);
	SV *	attribs = ST(1);
#line 292 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
#if defined(ORA_OCI_102)
	ub4 mode;
	ub4 flags;
	OCIAdmin *admhp;
	STRLEN svp_len;
	text *str;
#endif
#line 1722 "Oracle.c"
#line 302 "Oracle.xs"
#if defined(ORA_OCI_102)
	SV **svp;
	mode = OCI_DEFAULT;
	DBD_ATTRIB_GET_IV(attribs, "ora_mode", 8, svp, mode);
	flags = OCI_DEFAULT;
	DBD_ATTRIB_GET_IV(attribs, "ora_flags", 9, svp, flags);
    admhp = (OCIAdmin*)0;
	if ((svp=DBD_ATTRIB_GET_SVP(attribs, "ora_pfile", 9)) && SvOK(*svp)) {
		if (!SvPOK(*svp))
			croak("ora_pfile is not a string");
		str = (text*)SvPV(*svp, svp_len);
		OCIHandleAlloc(imp_dbh->envhp, (dvoid**)&admhp, (ub4)OCI_HTYPE_ADMIN, (size_t)0, (dvoid**)0);
		OCIAttrSet_log_stat(imp_dbh, (dvoid*)admhp, (ub4)OCI_HTYPE_ADMIN, (dvoid*)str, (ub4)svp_len, (ub4)OCI_ATTR_ADMIN_PFILE, (OCIError*)imp_dbh->errhp, status);
  }
	OCIDBStartup_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, admhp, mode, flags, status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCIDBStartup");
		ST(0) = &PL_sv_undef;
	}
	else {
		ST(0) = &PL_sv_yes;
	}
	if (admhp) OCIHandleFree_log_stat(imp_dbh, (dvoid*)admhp, (ub4)OCI_HTYPE_ADMIN, status);
#else
	croak("OCIDBStartup not available");
#endif
#line 1750 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_db_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_db_shutdown)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, attribs");
    {
	SV *	dbh = ST(0);
	SV *	attribs = ST(1);
#line 335 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
#if defined(ORA_OCI_102)
	ub4 mode;
	OCIAdmin *admhp;
#endif
#line 1776 "Oracle.c"
#line 342 "Oracle.xs"
#if defined(ORA_OCI_102)
	SV **svp;
	mode = OCI_DEFAULT;
	DBD_ATTRIB_GET_IV(attribs, "ora_mode", 8, svp, mode);
	admhp = (OCIAdmin*)0;
	OCIDBShutdown_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, admhp, mode, status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCIDBShutdown");
		ST(0) = &PL_sv_undef;
	}
	else {
		ST(0) = &PL_sv_yes;
	}
#else
	croak("OCIDBShutdown not available");
#endif
#line 1794 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_can_taf); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_can_taf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 363 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
	ub4 can_taf = 0;
#line 1816 "Oracle.c"
#line 367 "Oracle.xs"
#ifdef OCI_ATTR_TAF_ENABLED
	OCIAttrGet_log_stat(imp_dbh, imp_dbh->srvhp, OCI_HTYPE_SERVER, &can_taf, NULL,
				OCI_ATTR_TAF_ENABLED, imp_dbh->errhp, status);
	if (status != OCI_SUCCESS) {
# else
    if ( 1 ) {
# endif
		oci_error(dbh, imp_dbh->errhp, status, "OCIAttrGet OCI_ATTR_TAF_ENABLED");
		XSRETURN_IV(0);
	}
	else {
		XSRETURN_IV(can_taf);
	}
#line 1831 "Oracle.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DBD__Oracle__db_ora_ping); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_ping)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 385 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
#if defined(ORA_OCI_102)
	ub4 vernum;
#endif
 	text buf[2];
#line 1856 "Oracle.c"
#line 392 "Oracle.xs"
	/*when OCIPing not available,*/
	/*simply does a call to OCIServerVersion which should make 1 round trip*/
	/*later I will replace this with the actual OCIPing command*/
	/*This will work if the DB goes down, */
	/*If the listener goes down it is another case as the Listener is needed to establish the connection not maintain it*/
	/*so we should stay connected but we cannot get nay new connections*/
	{
        /* RT 69059 - despite OCIPing being introduced in 10.2
         * it is not available in all versions of 10.2 for AIX
         * e.g., 10.2.0.4 does not have it and 10.2.0.5 does
         * see http://comments.gmane.org/gmane.comp.lang.perl.modules.dbi.general/16206
         * We don't do versions to that accuracy so for AIX you have
         * to wait until 11.2 for OCIPing.
         *
         * Further comments on dbi-dev
         * "DBD::Oracle RTs a summary and request for help" suggested it
         * was Oracle bug 5759845 and fixes in 10.2.0.2.
         */
#if !defined(ORA_OCI_102) || (defined(_AIX) && !defined(ORA_OCI_112))
	OCIServerVersion_log_stat(imp_dbh, imp_dbh->svchp,imp_dbh->errhp,buf,2,OCI_HTYPE_SVCCTX,status);
#else
	vernum = ora_db_version(dbh,imp_dbh);
	/* OCIPing causes server failures if called against server ver < 10.2 */
	if (((int)((vernum>>24) & 0xFF) < 10 ) || (((int)((vernum>>24) & 0xFF) == 10 ) && ((int)((vernum>>20) & 0x0F) < 2 ))){
		OCIServerVersion_log_stat(imp_dbh, imp_dbh->svchp,imp_dbh->errhp,buf,2,OCI_HTYPE_SVCCTX,status);
	} else {
    	OCIPing_log_stat(imp_dbh, imp_dbh->svchp,imp_dbh->errhp,status);
	}
#endif
	if (status != OCI_SUCCESS){
		XSRETURN_IV(0);
	} else {
		XSRETURN_IV(1);
	}
}
#line 1893 "Oracle.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_DBD__Oracle__db_reauthenticate); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_reauthenticate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, uid, pwd");
    {
	SV *	dbh = ST(0);
	char *	uid = (char *)SvPV_nolen(ST(1));
	char *	pwd = (char *)SvPV_nolen(ST(2));
#line 435 "Oracle.xs"
	D_imp_dbh(dbh);
	ST(0) = ora_db_reauthenticate(dbh, imp_dbh, uid, pwd) ? &PL_sv_yes : &PL_sv_no;
#line 1916 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "dbh, locator, offset, data");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	UV	offset = (UV)SvUV(ST(2));
	SV *	data = ST(3);
#line 445 "Oracle.xs"
	D_imp_dbh(dbh);
	ub4 amtp;
	STRLEN data_len; /* bytes not chars */
	dvoid *bufp;
	sword status;
	ub2 csid;
	ub1 csform;
#line 1945 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_write",
			"locator", "OCILobLocatorPtr");
#line 453 "Oracle.xs"
	csid = 0;
	csform = SQLCS_IMPLICIT;
	bufp = SvPV(data, data_len);
	amtp = data_len;
	/* if locator is CLOB and data is UTF8 and not in bytes pragma */
	/* if (0 && SvUTF8(data) && !IN_BYTES) { amtp = sv_len_utf8(data); }  */
	/* added by lab: */
	/* LAB do something about length here? see above comment */
	 OCILobCharSetForm_log_stat(imp_dbh, imp_dbh->envhp, imp_dbh->errhp, locator, &csform, status );
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetForm");
	ST(0) = &PL_sv_undef;
		return;
	}
#ifdef OCI_ATTR_CHARSET_ID
	/* Effectively only used so AL32UTF8 works properly */
	OCILobCharSetId_log_stat(imp_dbh,
                             imp_dbh->envhp,
                             imp_dbh->errhp,
                             locator,
                             &csid,
                             status );
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetId");
	ST(0) = &PL_sv_undef;
		return;
	}
#endif /* OCI_ATTR_CHARSET_ID */
	/* if data is utf8 but charset isn't then switch to utf8 csid */
	csid = (SvUTF8(data) && !CS_IS_UTF8(csid)) ? utf8_csid : CSFORM_IMPLIED_CSID(csform);

	OCILobWrite_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator,
		&amtp, (ub4)offset,
		bufp, (ub4)data_len, OCI_ONE_PIECE,
		NULL, NULL,
		(ub2)0, csform , status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobWrite");
	ST(0) = &PL_sv_undef;
	}
	else {
		ST(0) = &PL_sv_yes;
	}
#line 1999 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, locator, data");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	SV *	data = ST(2);
#line 503 "Oracle.xs"
	D_imp_dbh(dbh);
	ub4 amtp;
	STRLEN data_len; /* bytes not chars */
	dvoid *bufp;
	sword status;
#if !defined(OCI_HTYPE_DIRPATH_FN_CTX) /* Oracle is < 9.0 */
	ub4 startp;
#endif
	ub1 csform;
	ub2 csid;
#line 2030 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_append",
			"locator", "OCILobLocatorPtr");
#line 514 "Oracle.xs"
	csid = 0;
	csform = SQLCS_IMPLICIT;
	bufp = SvPV(data, data_len);
	amtp = data_len;
	/* if locator is CLOB and data is UTF8 and not in bytes pragma */
	/* if (1 && SvUTF8(data) && !IN_BYTES) */
	/* added by lab: */
	/* LAB do something about length here? see above comment */
	OCILobCharSetForm_log_stat(imp_dbh, imp_dbh->envhp, imp_dbh->errhp, locator, &csform, status );
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetForm");
	ST(0) = &PL_sv_undef;
		return;
	}
#ifdef OCI_ATTR_CHARSET_ID
	/* Effectively only used so AL32UTF8 works properly */
	OCILobCharSetId_log_stat(imp_dbh,
                             imp_dbh->envhp,
                             imp_dbh->errhp,
                             locator,
                             &csid,
                             status );
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetId");
	ST(0) = &PL_sv_undef;
		return;
	}
#endif /* OCI_ATTR_CHARSET_ID */
	/* if data is utf8 but charset isn't then switch to utf8 csid */
	csid = (SvUTF8(data) && !CS_IS_UTF8(csid)) ? utf8_csid : CSFORM_IMPLIED_CSID(csform);
	OCILobWriteAppend_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator,
				   &amtp, bufp, (ub4)data_len, OCI_ONE_PIECE,
				   NULL, NULL,
				   csid, csform, status);
	if (status != OCI_SUCCESS) {
	   oci_error(dbh, imp_dbh->errhp, status, "OCILobWriteAppend");
	   ST(0) = &PL_sv_undef;
	}
	else {
	   ST(0) = &PL_sv_yes;
	}
#line 2082 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "dbh, locator, offset, length");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	UV	offset = (UV)SvUV(ST(2));
	UV	length = (UV)SvUV(ST(3));
#line 566 "Oracle.xs"
	D_imp_dbh(dbh);
	ub4 amtp;
	STRLEN bufp_len;
	SV *dest_sv;
	dvoid *bufp;
	sword status;
	ub1 csform;
#line 2111 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_read",
			"locator", "OCILobLocatorPtr");
#line 575 "Oracle.xs"
	csform = SQLCS_IMPLICIT;
    /* NOTE, if length is 0 this will create an empty SV of undef
       see RT55028 */
	dest_sv = sv_2mortal(newSV(length*4)); /*LAB: crude hack that works... tim did it else where XXX */

    if (length > 0) {
        SvPOK_on(dest_sv);
        bufp_len = SvLEN(dest_sv);	/* XXX bytes not chars? (lab: yes) */
        bufp = SvPVX(dest_sv);
        amtp = length;	/* if utf8 and clob/nclob: in: chars, out: bytes */
        /* http://www.lc.leidenuniv.nl/awcourse/oracle/appdev.920/a96584/oci16m40.htm#427818 */
        /* if locator is CLOB and data is UTF8 and not in bytes pragma */
        /* if (0 && SvUTF8(dest_sv) && !IN_BYTES) { amtp = sv_len_utf8(dest_sv); }  */
        /* added by lab: */
        OCILobCharSetForm_log_stat(imp_dbh,  imp_dbh->envhp, imp_dbh->errhp, locator, &csform, status );
        if (status != OCI_SUCCESS) {
            oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetForm");
            dest_sv = &PL_sv_undef;
            return;
        }
        {
            /* see rt 75163 */
            boolean is_open;

            OCILobFileIsOpen_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator, &is_open, status);
            if (status == OCI_SUCCESS && !is_open) {
                OCILobFileOpen_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator,
                                        (ub1)OCI_FILE_READONLY, status);
                if (status != OCI_SUCCESS) {
                    oci_error(dbh, imp_dbh->errhp, status, "OCILobFileOpen");
                    dest_sv = &PL_sv_undef;
                }
            }
        }

        OCILobRead_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator,
                            &amtp, (ub4)offset, /* offset starts at 1 */
                            bufp, (ub4)bufp_len,
                            0, 0, (ub2)0, csform, status);
        if (status != OCI_SUCCESS) {
            oci_error(dbh, imp_dbh->errhp, status, "OCILobRead");
            dest_sv = &PL_sv_undef;
        }
        else {
            SvCUR(dest_sv) = amtp; /* always bytes here */
            *SvEND(dest_sv) = '\0';
            if (csform){
                if (CSFORM_IMPLIES_UTF8(csform)){
                    SvUTF8_on(dest_sv);
                }
            }
        }
    } /* length > 0 */

	ST(0) = dest_sv;
#line 2177 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_trim); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_trim)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, locator, length");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	UV	length = (UV)SvUV(ST(2));
#line 637 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
#line 2200 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_trim",
			"locator", "OCILobLocatorPtr");
#line 640 "Oracle.xs"
	OCILobTrim_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator, length, status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobTrim");
	ST(0) = &PL_sv_undef;
	}
	else {
	ST(0) = &PL_sv_yes;
	}
#line 2219 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_is_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_is_init)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, locator");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
#line 654 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
	boolean is_init = 0;
#line 2242 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_is_init",
			"locator", "OCILobLocatorPtr");
#line 658 "Oracle.xs"
	OCILobLocatorIsInit_log_stat(imp_dbh, imp_dbh->envhp,imp_dbh->errhp,locator,&is_init,status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobLocatorIsInit ora_lob_is_init");
	    ST(0) = &PL_sv_undef;
	}
	else {
	    ST(0) = sv_2mortal(newSVuv(is_init));
	}
#line 2261 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_length); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_length)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, locator");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
#line 672 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
	ub4 len = 0;
#line 2284 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_length",
			"locator", "OCILobLocatorPtr");
#line 676 "Oracle.xs"
	OCILobGetLength_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator, &len, status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobGetLength ora_lob_length");
	ST(0) = &PL_sv_undef;
	}
	else {
	ST(0) = sv_2mortal(newSVuv(len));
	}
#line 2303 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__db_ora_lob_chunk_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_chunk_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, locator");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
#line 691 "Oracle.xs"
	D_imp_dbh(dbh);
	sword status;
	ub4 chunk_size = 0;
#line 2326 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"DBD::Oracle::db::ora_lob_chunk_size",
			"locator", "OCILobLocatorPtr");
#line 695 "Oracle.xs"
	OCILobGetChunkSize_log_stat(imp_dbh, imp_dbh->svchp, imp_dbh->errhp, locator, &chunk_size, status);
	if (status != OCI_SUCCESS) {
		oci_error(dbh, imp_dbh->errhp, status, "OCILobGetChunkSize");
		ST(0) = &PL_sv_undef;
	}
	else {
		ST(0) = sv_2mortal(newSVuv(chunk_size));
	}
#line 2345 "Oracle.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Oracle__dr_init_oci); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_init_oci)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0);
#line 711 "Oracle.xs"
	D_imp_drh(drh);
	dbd_init_oci(DBIS) ;
	dbd_init_oci_drh(imp_drh) ;
#line 2367 "Oracle.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_DBD__Oracle); /* prototype to pass -Wmissing-prototypes */
XS(boot_DBD__Oracle)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        cv = newXS("DBD::Oracle::OCI_FO_SELECT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_SELECT ;
        cv = newXS("DBD::Oracle::ORA_ROWID", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_ROWID ;
        cv = newXS("DBD::Oracle::ORA_MLSLABEL", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 105 ;
        cv = newXS("DBD::Oracle::ORA_RAW", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_RAW ;
        cv = newXS("DBD::Oracle::OCI_FO_NONE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_NONE ;
        cv = newXS("DBD::Oracle::OCI_FETCH_FIRST", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_FIRST ;
        cv = newXS("DBD::Oracle::OCI_FO_ERROR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_ERROR ;
        cv = newXS("DBD::Oracle::OCI_DESCRIBE_ONLY", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x10 ;
        cv = newXS("DBD::Oracle::OCI_FO_RETRY", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_RETRY ;
        cv = newXS("DBD::Oracle::OCI_BATCH_ERRORS", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x80 ;
        cv = newXS("DBD::Oracle::ORA_STRING", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_STRING ;
        cv = newXS("DBD::Oracle::OCI_DBSHUTDOWN_ABORT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("DBD::Oracle::ORA_VARCHAR2", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_VARCHAR2 ;
        cv = newXS("DBD::Oracle::OCI_FETCH_CURRENT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_CURRENT ;
        cv = newXS("DBD::Oracle::OCI_BATCH_MODE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x01 ;
        cv = newXS("DBD::Oracle::ORA_VARCHAR2_TABLE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_VARCHAR2_TABLE ;
        cv = newXS("DBD::Oracle::OCI_DBSTARTUPFLAG_RESTRICT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x00000002 ;
        cv = newXS("DBD::Oracle::ORA_CHAR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_CHAR ;
        cv = newXS("DBD::Oracle::OCI_DBSHUTDOWN_FINAL", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 5 ;
        cv = newXS("DBD::Oracle::OCI_PARSE_ONLY", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x100 ;
        cv = newXS("DBD::Oracle::OCI_FO_BEGIN", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_BEGIN ;
        cv = newXS("DBD::Oracle::SQLT_CHR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLT_CHR ;
        cv = newXS("DBD::Oracle::OCI_FO_SESSION", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_SESSION ;
        cv = newXS("DBD::Oracle::OCI_FO_ABORT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_ABORT ;
        cv = newXS("DBD::Oracle::OCI_STMT_SCROLLABLE_READONLY", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x08 ;
        cv = newXS("DBD::Oracle::OCI_KEEP_FETCH_STATE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x04 ;
        cv = newXS("DBD::Oracle::SQLT_INT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLT_INT ;
        cv = newXS("DBD::Oracle::OCI_FETCH_PRIOR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_PRIOR ;
        cv = newXS("DBD::Oracle::ORA_NUMBER", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_NUMBER ;
        cv = newXS("DBD::Oracle::OCI_PRELIM_AUTH", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x00000008 ;
        cv = newXS("DBD::Oracle::OCI_FETCH_NEXT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_NEXT ;
        cv = newXS("DBD::Oracle::ORA_SYSOPER", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x0004 ;
        cv = newXS("DBD::Oracle::ORA_DATE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_DATE ;
        cv = newXS("DBD::Oracle::ORA_XMLTYPE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_XMLTYPE ;
        cv = newXS("DBD::Oracle::OCI_FETCH_RELATIVE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_RELATIVE ;
        cv = newXS("DBD::Oracle::OCI_COMMIT_ON_SUCCESS", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x20 ;
        cv = newXS("DBD::Oracle::OCI_DBSTARTUPFLAG_FORCE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x00000001 ;
        cv = newXS("DBD::Oracle::ORA_CLOB", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_CLOB ;
        cv = newXS("DBD::Oracle::OCI_EXACT_FETCH", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x02 ;
        cv = newXS("DBD::Oracle::ORA_SYSDBA", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x0002 ;
        cv = newXS("DBD::Oracle::ORA_SYSASM", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x8000 ;
        cv = newXS("DBD::Oracle::SQLCS_IMPLICIT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLCS_IMPLICIT ;
        cv = newXS("DBD::Oracle::OCI_DBSHUTDOWN_IMMEDIATE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 3 ;
        cv = newXS("DBD::Oracle::ORA_BLOB", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_BLOB ;
        cv = newXS("DBD::Oracle::ORA_LONGRAW", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_LONGRAW ;
        cv = newXS("DBD::Oracle::OCI_NON_BLOCKING", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x40 ;
        cv = newXS("DBD::Oracle::OCI_FO_REAUTH", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_REAUTH ;
        cv = newXS("DBD::Oracle::constant", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::OCI_FO_TXNAL", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_TXNAL ;
        cv = newXS("DBD::Oracle::SQLT_FLT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLT_FLT ;
        cv = newXS("DBD::Oracle::OCI_FETCH_ABSOLUTE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_ABSOLUTE ;
        cv = newXS("DBD::Oracle::OCI_DBSHUTDOWN_TRANSACTIONAL", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::OCI_DBSHUTDOWN_TRANSACTIONAL_LOCAL", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("DBD::Oracle::ORA_SYSBACKUP", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x00020000 ;
        cv = newXS("DBD::Oracle::OCI_FETCH_LAST", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FETCH_LAST ;
        cv = newXS("DBD::Oracle::SQLT_BIN", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLT_BIN ;
        cv = newXS("DBD::Oracle::OCI_FO_END", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = OCI_FO_END ;
        cv = newXS("DBD::Oracle::ORA_NUMBER_TABLE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_NUMBER_TABLE ;
        cv = newXS("DBD::Oracle::OCI_SHOW_DML_WARNINGS", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x400 ;
        cv = newXS("DBD::Oracle::ORA_RSET", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_RSET ;
        cv = newXS("DBD::Oracle::SQLCS_NCHAR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLCS_NCHAR ;
        cv = newXS("DBD::Oracle::ORA_SYSDG", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x00040000 ;
        cv = newXS("DBD::Oracle::ORA_LONG", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_LONG ;
        cv = newXS("DBD::Oracle::ORA_CHARZ", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = ORA_CHARZ ;
        cv = newXS("DBD::Oracle::ORA_SYSKM", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x00080000 ;
        newXS("DBD::Oracle::ORA_OCI", XS_DBD__Oracle_ORA_OCI, file);
        newXS("DBD::Oracle::ora_env_var", XS_DBD__Oracle_ora_env_var, file);
#if XSubPPtmpAAAA
        newXS("DBD::Oracle::ora_cygwin_set_env", XS_DBD__Oracle_ora_cygwin_set_env, file);
#endif
        newXS("DBD::Oracle::dr::dbixs_revision", XS_DBD__Oracle__dr_dbixs_revision, file);
#if XSubPPtmpAAAB
        cv = newXS("DBD::Oracle::dr::disconnect_all", XS_DBD__Oracle__dr_discon_all_, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::dr::discon_all_", XS_DBD__Oracle__dr_discon_all_, file);
        XSANY.any_i32 = 0 ;
#endif
#if XSubPPtmpAAAC
        newXS("DBD::Oracle::dr::data_sources", XS_DBD__Oracle__dr_data_sources, file);
#endif
        newXS("DBD::Oracle::db::_login", XS_DBD__Oracle__db__login, file);
        newXS("DBD::Oracle::db::selectall_arrayref", XS_DBD__Oracle__db_selectall_arrayref, file);
        cv = newXS("DBD::Oracle::db::selectrow_arrayref", XS_DBD__Oracle__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::db::selectrow_array", XS_DBD__Oracle__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1 ;
#if XSubPPtmpAAAD
        newXS("DBD::Oracle::db::do", XS_DBD__Oracle__db_do, file);
#endif
#if XSubPPtmpAAAE
        newXS("DBD::Oracle::db::last_insert_id", XS_DBD__Oracle__db_last_insert_id, file);
#endif
        newXS("DBD::Oracle::db::commit", XS_DBD__Oracle__db_commit, file);
        newXS("DBD::Oracle::db::rollback", XS_DBD__Oracle__db_rollback, file);
        newXS("DBD::Oracle::db::disconnect", XS_DBD__Oracle__db_disconnect, file);
        newXS("DBD::Oracle::db::STORE", XS_DBD__Oracle__db_STORE, file);
        newXS("DBD::Oracle::db::FETCH", XS_DBD__Oracle__db_FETCH, file);
        newXS("DBD::Oracle::db::DESTROY", XS_DBD__Oracle__db_DESTROY, file);
#if XSubPPtmpAAAF
        newXS("DBD::Oracle::db::take_imp_data", XS_DBD__Oracle__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAG
        newXS("DBD::Oracle::db::data_sources", XS_DBD__Oracle__db_data_sources, file);
#endif
        newXS("DBD::Oracle::st::_prepare", XS_DBD__Oracle__st__prepare, file);
#if XSubPPtmpAAAH
        newXS("DBD::Oracle::st::rows", XS_DBD__Oracle__st_rows, file);
#endif
#if XSubPPtmpAAAI
        newXS("DBD::Oracle::st::bind_col", XS_DBD__Oracle__st_bind_col, file);
#endif
        newXS("DBD::Oracle::st::bind_param", XS_DBD__Oracle__st_bind_param, file);
        newXS("DBD::Oracle::st::bind_param_inout", XS_DBD__Oracle__st_bind_param_inout, file);
        newXS("DBD::Oracle::st::execute", XS_DBD__Oracle__st_execute, file);
#if XSubPPtmpAAAJ
        newXS("DBD::Oracle::st::execute_for_fetch", XS_DBD__Oracle__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::Oracle::st::fetchrow_arrayref", XS_DBD__Oracle__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::st::fetch", XS_DBD__Oracle__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::st::fetchrow_array", XS_DBD__Oracle__st_fetchrow_array, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::st::fetchrow", XS_DBD__Oracle__st_fetchrow_array, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::Oracle::st::fetchall_arrayref", XS_DBD__Oracle__st_fetchall_arrayref, file);
        newXS("DBD::Oracle::st::finish", XS_DBD__Oracle__st_finish, file);
        newXS("DBD::Oracle::st::blob_read", XS_DBD__Oracle__st_blob_read, file);
        newXS("DBD::Oracle::st::STORE", XS_DBD__Oracle__st_STORE, file);
        cv = newXS("DBD::Oracle::st::FETCH_attrib", XS_DBD__Oracle__st_FETCH_attrib, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::st::FETCH", XS_DBD__Oracle__st_FETCH_attrib, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::Oracle::st::DESTROY", XS_DBD__Oracle__st_DESTROY, file);
        newXS("DBD::Oracle::st::ora_stmt_type", XS_DBD__Oracle__st_ora_stmt_type, file);
        newXS("DBD::Oracle::st::ora_stmt_type_name", XS_DBD__Oracle__st_ora_stmt_type_name, file);
        newXS("DBD::Oracle::st::ora_scroll_position", XS_DBD__Oracle__st_ora_scroll_position, file);
        newXS("DBD::Oracle::st::ora_fetch_scroll", XS_DBD__Oracle__st_ora_fetch_scroll, file);
        newXS("DBD::Oracle::st::ora_bind_param_inout_array", XS_DBD__Oracle__st_ora_bind_param_inout_array, file);
        newXS("DBD::Oracle::st::ora_fetch", XS_DBD__Oracle__st_ora_fetch, file);
        newXS("DBD::Oracle::st::ora_execute_array", XS_DBD__Oracle__st_ora_execute_array, file);
        newXS("DBD::Oracle::st::cancel", XS_DBD__Oracle__st_cancel, file);
        newXS("DBD::Oracle::db::ora_db_startup", XS_DBD__Oracle__db_ora_db_startup, file);
        newXS("DBD::Oracle::db::ora_db_shutdown", XS_DBD__Oracle__db_ora_db_shutdown, file);
        newXS("DBD::Oracle::db::ora_can_taf", XS_DBD__Oracle__db_ora_can_taf, file);
        newXS("DBD::Oracle::db::ora_ping", XS_DBD__Oracle__db_ora_ping, file);
        newXS("DBD::Oracle::db::reauthenticate", XS_DBD__Oracle__db_reauthenticate, file);
        newXS("DBD::Oracle::db::ora_lob_write", XS_DBD__Oracle__db_ora_lob_write, file);
        newXS("DBD::Oracle::db::ora_lob_append", XS_DBD__Oracle__db_ora_lob_append, file);
        newXS("DBD::Oracle::db::ora_lob_read", XS_DBD__Oracle__db_ora_lob_read, file);
        newXS("DBD::Oracle::db::ora_lob_trim", XS_DBD__Oracle__db_ora_lob_trim, file);
        newXS("DBD::Oracle::db::ora_lob_is_init", XS_DBD__Oracle__db_ora_lob_is_init, file);
        newXS("DBD::Oracle::db::ora_lob_length", XS_DBD__Oracle__db_ora_lob_length, file);
        newXS("DBD::Oracle::db::ora_lob_chunk_size", XS_DBD__Oracle__db_ora_lob_chunk_size, file);
        newXS("DBD::Oracle::dr::init_oci", XS_DBD__Oracle__dr_init_oci, file);
    }

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 18 "./Oracle.xsi"
    items = 0;  /* avoid 'unused variable' warning */
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::Oracle::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::Oracle::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::Oracle::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#line 2649 "Oracle.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

